{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TASKED App Documentation","text":"<p>Welcome to the documentation for TASKED application. This is a task management system built with Flask, using PostgreSQL and MongoDB. It supports user authentication through Google OAuth.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>User authentication via Google OAuth</li> <li>Task management with CRUD operations (Create, Read, Update, Delete)</li> <li>MongoDB for task storage</li> <li>PostgreSQL for user data</li> <li>API for authentication</li> <li>Automated tests with pytest</li> <li>Github actions for deploy and testing.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#clone-the-repository","title":"Clone the repository","text":"<p><code>git clone https://github.com/MILZEN/TODO-main</code></p>"},{"location":"#install-dependencies","title":"Install dependencies","text":"<p><code>pip install -r requirements.txt</code></p>"},{"location":"#set-up-environment-variables","title":"Set up Environment Variables","text":""},{"location":"#run-te-application","title":"Run te application","text":""},{"location":"installation/","title":"Installation Guide","text":""},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7+</li> <li>pip package manager</li> <li>Virtual environment (recommender)</li> <li>Google account</li> </ul>"},{"location":"installation/#step-by-step-installation","title":"Step-by-Step Installation","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>   git clone https://github.com/yourusername/flask-todo-app\n   cd flask-todo-app\n</code></pre> <ol> <li>Create virtual environment</li> </ol> <pre><code>   python3 -m venv venv\n   source venv/bin/activate # On Windows: venv\\Scripts\\activate\n</code></pre>"},{"location":"api/authentication/","title":"Authentication API","text":""},{"location":"api/authentication/#overview","title":"Overview","text":"<p>This application uses Google OAuth for user authentication. Google OAuth allows users to log in securely using their Google account, providing a seamless authentication flow.</p>"},{"location":"api/authentication/#login-with-google-oauth","title":"Login with Google OAuth","text":"<p>Users can authenticate by logging in with their Google account.</p>"},{"location":"api/authentication/#authentication-flow","title":"Authentication Flow","text":"<ol> <li>User clicks the 'Login with Google' button.</li> <li>Redirect to Google OAuth: The user is redirected to Google's OAuth 2.0 server.</li> <li>User grants permissions: After granting necessary permissions, Google redirects the user back to the application.</li> <li>Access Token: The application retrieves an access token from Google to authenticate the user.</li> <li>Session creation: A session is created to keep the user logged in.</li> </ol>"},{"location":"api/authentication/#request","title":"Request","text":"<p>No manual API request is required from the user side. The authentication flow is handled via a redirection to Google and a callback handler in the app.</p>"},{"location":"api/authentication/#response","title":"Response","text":"<ul> <li>Success: The user is logged in, and a session is created.</li> <li>Failure: If authentication fails, the user is redirected back to the login page with an error message.</li> </ul>"},{"location":"api/authentication/#example","title":"Example","text":"<ul> <li>Login URL: <code>/login/google</code></li> <li>Redirect URL after successful login: <code>/home/&lt;username&gt;</code></li> </ul> <p>For any error, the user is redirected back to the login page with an error message.</p>"},{"location":"api/authentication/#logout","title":"Logout","text":"<p>To log out, users can simply click the \"Logout\" button, which will terminate their session.</p>"},{"location":"api/tasks/","title":"Tasks API","text":""},{"location":"api/tasks/#overview","title":"Overview","text":"<p>This application allows users to create, view, edit, and delete tasks. The tasks are stored in the MongoDB database and are associated with the authenticated user.</p>"},{"location":"api/tasks/#task-management","title":"Task Management","text":"<p>Tasks are managed through the application\u2019s front-end, and there is no separate API exposed for tasks.</p>"},{"location":"api/tasks/#add-task","title":"Add Task","text":"<p>Users can add tasks by filling out a form with the task's title, priority, and completion status. Tasks are added via the web interface (no manual API calls are made). The data is sent to the back-end as part of a form submission.</p> <ul> <li>Method: <code>POST</code></li> <li>Route: <code>/add/&lt;username&gt;</code></li> <li>Data: </li> <li><code>title</code> (string): The title of the task.</li> <li><code>priority</code> (string): The priority level of the task (e.g., High, Medium, Low).</li> <li><code>username</code> (string): The username of that user use.</li> <li><code>completed</code> (boolean): Whether the task is completed or not.</li> </ul>"},{"location":"api/tasks/#example","title":"Example","text":"<pre><code>{\n  title: \"New task!\"\n  priority: \"medium\"\n  username: \"Admin\"\n  completed: true\n}\n</code></pre>"},{"location":"api/tasks/#view-tasks","title":"View Tasks","text":"<p>Tasks associated with the authenticated user can be viewed on the user's home page.</p> <ul> <li>Method: <code>GET</code></li> <li>Route: <code>/home/&lt;username&gt;</code></li> </ul>"},{"location":"api/tasks/#edit-task","title":"Edit Task","text":"<p>Users can edit their tasks, including the title and completion status.</p> <ul> <li>Method: <code>POST</code></li> <li>Route: <code>/edit/&lt;id&gt;</code></li> <li>Data:</li> <li><code>title</code> (string): The updated task title.</li> <li><code>completed</code> (boolean): Whether the task is completed or not.</li> </ul>"},{"location":"api/tasks/#delete-task","title":"Delete Task","text":"<p>Users can delete tasks.</p> <ul> <li>Method: <code>DELETE</code></li> <li>Route: <code>'/delete/&lt;id&gt;'</code></li> </ul>"},{"location":"testing/e2e/","title":"End-to-End (E2E) Tests Documentation","text":"<p>This document describes the End-to-End (E2E) tests implemented for the application. E2E tests ensure that the application behaves as expected from the user's perspective, covering workflows like registration, task creation, editing, and deletion.</p>"},{"location":"testing/e2e/#auth-flow-e2e-test-test_auth_flowpy","title":"Auth Flow E2E Test (<code>test_auth_flow.py</code>)","text":""},{"location":"testing/e2e/#test_user_registration","title":"<code>test_user_registration</code>","text":"<ul> <li>Description: This test simulates a user registration flow, checking that a user can successfully register and is redirected to the login page.</li> <li>Test Logic:<ul> <li>The test uses Playwright to open a Chromium browser in headless mode.</li> <li>The test navigates to the registration page, fills in the registration form with user details, and submits the form.</li> <li>After submitting the form, the test verifies that the user is redirected to the login page by checking if the page title contains <code>\"User Login\"</code>.</li> </ul> </li> <li> <p>Expected Outcome: The user should be successfully registered, and the browser should redirect to the login page.</p> <p>```python def test_user_registration():     with sync_playwright() as p:         browser = p.chromium.launch(headless=True)  # Launching in headless mode         page = browser.new_page()</p> <pre><code>    # Go to the registration page\n    page.goto(\"http://localhost:5000/register\")\n\n    # Fill the registration form\n    page.fill(\"input[name='username']\", \"testuser\")\n    page.fill(\"input[name='password']\", \"password\")\n    page.click(\"button[type='submit']\")\n\n    # Verify redirection to the login page\n    assert \"User Login\" in page.title()  # Verify the title is \"Login\"\n\n    browser.close()\n</code></pre> <p>```</p> </li> </ul>"},{"location":"testing/e2e/#task-flow-e2e-tests-test_task_flowpy","title":"Task Flow E2E Tests (<code>test_task_flow.py</code>)","text":""},{"location":"testing/e2e/#test_register_and_create_task","title":"<code>test_register_and_create_task</code>","text":"<ul> <li>Description: This test covers the process of registering a new user and then creating a task.</li> <li>Test Logic:<ul> <li>The test navigates to the registration page and fills in the registration form.</li> <li>After the user is registered and redirected to the home page, the test creates a new task by filling in the title and priority fields and submitting the form.</li> <li>After submission, the test waits for the task list to update and verifies that the newly created task is visible on the page.</li> </ul> </li> <li> <p>Expected Outcome: The user should be able to create a task successfully, and the task should appear in the task list.</p> <p>```python def test_register_and_create_task():     with sync_playwright() as p:         browser = p.chromium.launch(headless=True)         page = browser.new_page()</p> <pre><code>    # Register a new user\n    page.goto(\"http://localhost:5000/register\")\n    page.fill(\"input[name='username']\", \"testuser\")\n    page.fill(\"input[name='email']\", \"testuser@example.com\")\n    page.fill(\"input[name='password']\", \"testpassword\")\n    page.fill(\"input[name='first_name']\", \"Test\")\n    page.fill(\"input[name='last_name']\", \"User\")\n    page.click(\"button[type='submit']\")\n    # Wait for redirection to the home page\n    page.wait_for_url(\"http://localhost:5000/\")\n\n    # Create a new task (wait for task input to be available)\n    page.fill(\"input[name='title']\", \"Test Task\")\n    page.fill(\"select[name='priority']\", \"High\")\n    page.click(\"button[type='submit']\")\n\n    # Wait for the task list to update\n    page.wait_for_selector(\"ul#task-list li\")\n\n    # Verify that the task was created\n    assert \"Test Task\" in page.content()\n\n    browser.close()\n</code></pre> <p>```</p> </li> </ul>"},{"location":"testing/e2e/#test_edit_and_delete_task","title":"<code>test_edit_and_delete_task</code>","text":"<ul> <li>Description: This test verifies that a user can edit and delete a task after logging in.</li> <li>Test Logic:<ul> <li>The test starts by logging in with a previously registered user.</li> <li>After logging in, it navigates to the user's home page and locates an existing task.</li> <li>The test edits the task by changing its title and submits the changes, then verifies that the task has been updated.</li> <li>It then deletes the task and verifies that the task no longer exists in the task list.</li> </ul> </li> <li> <p>Expected Outcome: The task should be updated and deleted successfully, with the changes reflected on the page.</p> <p>```python def test_edit_and_delete_task():     with sync_playwright() as p:         browser = p.chromium.launch(headless=True)         page = browser.new_page()</p> <pre><code>    # Log in to the application\n    page.goto(\"http://localhost:5000/login\")\n    page.fill(\"input[name='email']\", \"testuser@example.com\")  # Use valid email\n    page.fill(\"input[name='password']\", \"testpassword\")\n    page.click(\"button[type='submit']\")\n    # Wait for the page to load completely\n    page.wait_for_load_state(\"load\")\n\n    # Wait for the home page to be ready\n    page.wait_for_selector(\"h1\")\n\n    # Go to the user's home page\n    username = \"testuser\"  # Must match the username after login\n    page.goto(f\"http://localhost:5000/home/{username}\")\n\n    # Edit the task\n    task = page.locator(\"text=Test Task\")\n    task.click()\n    page.click(\"button:has-text('Edit')\")\n    page.fill(\"input[name='title']\", \"Updated Task\")\n    page.click(\"button[type='submit']\")\n    time.sleep(2)  # Wait for the update\n\n    # Verify that the task was updated\n    assert \"Updated Task\" in page.content()\n\n    # Delete the task\n    page.click(\"button:has-text('Delete')\")\n    time.sleep(2)  # Wait for the deletion\n\n    # Verify that the task was deleted\n    assert \"Updated Task\" not in page.content()\n\n    browser.close()\n</code></pre> <p>```</p> </li> </ul>"},{"location":"testing/e2e/#summary","title":"Summary","text":"<p>The End-to-End tests simulate real user interactions with the application, ensuring that registration, task creation, task editing, and task deletion work as expected. These tests cover the full flow of the application and validate the most critical user actions.</p>"},{"location":"testing/integration/","title":"Integration Tests Documentation","text":"<p>This document provides an overview of the integration tests implemented for the application. The tests focus on ensuring the correct interaction between different components of the system, such as database connections and OAuth authentication.</p>"},{"location":"testing/integration/#database-integration-tests-test_dbpy","title":"Database Integration Tests (<code>test_db.py</code>)","text":""},{"location":"testing/integration/#test_db_connection","title":"<code>test_db_connection</code>","text":"<ul> <li>Description: This test verifies that the database connection can be successfully established.</li> <li>Test Logic:<ul> <li>The <code>create_connection</code> function, responsible for establishing a connection to the database, is mocked to always return <code>True</code>.</li> <li>The test checks if the connection is successful by asserting that the mock connection object returns <code>True</code>.</li> </ul> </li> <li> <p>Expected Outcome: The connection should be established successfully, and the test should pass by returning <code>True</code>.</p> <p><code>python def test_db_connection(mocker):     # Using mock to connection function     mock_connection = mocker.patch(\"app.create_connection\", return_value=True)     connection = mock_connection()     assert connection is True  # Verifying if the connection is successful</code></p> </li> </ul>"},{"location":"testing/integration/#oauth-integration-tests-test_oauthpy","title":"OAuth Integration Tests (<code>test_oauth.py</code>)","text":""},{"location":"testing/integration/#test_google_login","title":"<code>test_google_login</code>","text":"<ul> <li>Description: This test checks if the Google OAuth login works correctly by simulating the redirection to the login page.</li> <li>Test Logic:<ul> <li>The <code>login_google</code> view function is patched using <code>monkeypatch</code> to return a mocked redirection response, instead of performing the actual OAuth flow.</li> <li>A <code>GET</code> request is sent to the <code>/login/google</code> endpoint to simulate the login action.</li> <li>The test verifies that the mocked redirection response is returned by checking if the response contains the string <code>\"Mocked OAuth Redirect\"</code>.</li> </ul> </li> <li> <p>Expected Outcome: The OAuth login should be simulated successfully, and the test should pass by verifying that the redirection message is in the response.</p> <p>```python def test_google_login(client, monkeypatch):     # Mocking the redirection function     def mock_redirect(args, *kwargs):         return \"Mocked OAuth Redirect\"</p> <pre><code># Replacing the view function directly\nmonkeypatch.setattr('app.view_functions.login_google', mock_redirect)\n\n# Login request\nresponse = client.get('/login/google')\n\n# Verify simulated answer\nassert \"Mocked OAuth Redirect\" in response.data.decode()\n</code></pre> <p>```</p> </li> </ul>"},{"location":"testing/integration/#summary","title":"Summary","text":"<p>The integration tests cover key interactions between different components of the application, such as the database connection and the OAuth login process. These tests ensure that the system works as expected when different parts of the application communicate with each other, and help prevent potential integration issues.</p>"},{"location":"testing/unit/","title":"Unit Tests Documentation","text":"<p>This document provides an overview of the unit tests implemented for the application. The tests focus on various components of the system, including authentication, tasks, and utility functions.</p>"},{"location":"testing/unit/#authentication-tests-test_authpy","title":"Authentication Tests (<code>test_auth.py</code>)","text":""},{"location":"testing/unit/#test_gen_hash","title":"<code>test_gen_hash</code>","text":"<ul> <li>Description: This test verifies that the <code>gen_hash</code> function generates a hash that is different from the original password.</li> <li>Test Logic:<ul> <li>A password is provided to the <code>gen_hash</code> function.</li> <li>The generated hash is compared to the original password to ensure they are different.</li> </ul> </li> <li> <p>Expected Outcome: The hash should not be the same as the original password.</p> <p><code>python def test_gen_hash():     password = \"test_password\"     hashed = gen_hash(password)     assert hashed != password</code></p> </li> </ul>"},{"location":"testing/unit/#test_check_hash","title":"<code>test_check_hash</code>","text":"<ul> <li>Description: This test checks if the <code>check_hash</code> function correctly verifies a password against its hash.</li> <li>Test Logic:<ul> <li>A password is hashed using <code>gen_hash</code>.</li> <li>The <code>check_hash</code> function is then used to compare the original password with the hash.</li> <li>The test verifies that the password matches the hash and returns <code>True</code>.</li> </ul> </li> <li> <p>Expected Outcome: The password and hash should match, returning <code>True</code>.</p> <p><code>python def test_check_hash():     password = \"test_password\"     hashed = gen_hash(password)     assert check_hash(password, hashed) is True</code></p> </li> </ul>"},{"location":"testing/unit/#task-management-tests-test_taskspy","title":"Task Management Tests (<code>test_tasks.py</code>)","text":""},{"location":"testing/unit/#test_add_task","title":"<code>test_add_task</code>","text":"<ul> <li>Description: This test simulates adding a new task to the database via a POST request to the <code>/add/test_user</code> endpoint.</li> <li>Test Logic:<ul> <li>The <code>mock_db</code> is used to simulate the insertion of a task into the database.</li> <li>A task data object is created, containing the task's title, priority, username, and completion status.</li> <li>A POST request is sent to the <code>/add/test_user</code> route with task data as the payload.</li> <li>The test verifies that the response status code is 200 and that the <code>insert_one</code> method of the mock database was called once with the expected task data.</li> </ul> </li> <li> <p>Expected Outcome: The database insertion should be mocked correctly, and the response should return a status code of 200.</p> <p>```python def test_add_task(client, mock_db, mocker):     # Simulating the database insert with mock     mock_db.tasks.insert_one.return_value = None</p> <pre><code># Expected data for the insert\ntask_data = {\"title\": \"Task 1\", \"priority\": \"High\", \"username\": \"test_user\", \"completed\": False}\n\n# POST request\nresponse = client.post('/add/test_user', data={\"title\": \"Task 1\", \"priority\": \"High\"})\n\n# Verifying the response status code\nassert response.status_code == 200\n\n# Verify insert_one function is called with the expected data\nmock_db.tasks.insert_one.assert_called_once_with(task_data)\n</code></pre> <p>```</p> </li> </ul>"},{"location":"testing/unit/#utility-tests-test_utilpy","title":"Utility Tests (<code>test_util.py</code>)","text":""},{"location":"testing/unit/#test_gen_hash_creates_hash","title":"<code>test_gen_hash_creates_hash</code>","text":"<ul> <li>Description: This test checks that the <code>gen_hash</code> function creates a non-empty hash that is different from the original password.</li> <li>Test Logic:<ul> <li>A password is hashed using the <code>gen_hash</code> function.</li> <li>The generated hash is checked to ensure it is not empty and that it differs from the original password.</li> </ul> </li> <li> <p>Expected Outcome: The hash should be different from the original password and not empty.</p> <p><code>python def test_gen_hash_creates_hash():     password = \"my_secure_password\"     hashed_password = gen_hash(password)     assert hashed_password != password  # The hash should be different from the plaintext     assert len(hashed_password) &gt; 0  # The hash should not be empty</code></p> </li> </ul>"},{"location":"testing/unit/#test_check_hash_valid","title":"<code>test_check_hash_valid</code>","text":"<ul> <li>Description: This test verifies that the <code>check_hash</code> function correctly compares a valid password with its hash.</li> <li>Test Logic:<ul> <li>A password is hashed.</li> <li>The <code>check_hash</code> function is used to compare the password with the hash.</li> <li>The test asserts that the comparison returns <code>True</code> for the correct password.</li> </ul> </li> <li> <p>Expected Outcome: The comparison should return <code>True</code> for the correct password.</p> <p><code>python def test_check_hash_valid():     password = \"my_secure_password\"     hashed_password = gen_hash(password)     assert check_hash(password, hashed_password) is True  # Comparison must be valid</code></p> </li> </ul>"},{"location":"testing/unit/#test_check_hash_invalid","title":"<code>test_check_hash_invalid</code>","text":"<ul> <li>Description: This test checks if the <code>check_hash</code> function correctly returns <code>False</code> when comparing an incorrect password with a hash.</li> <li>Test Logic:<ul> <li>A password is hashed.</li> <li>The <code>check_hash</code> function is used to compare an incorrect password with the hash.</li> <li>The test asserts that the comparison returns <code>False</code> for the incorrect password.</li> </ul> </li> <li> <p>Expected Outcome: The comparison should return <code>False</code> for the incorrect password.</p> <p><code>python def test_check_hash_invalid():     password = \"my_secure_password\"     hashed_password = gen_hash(password)     # Must fail with incorrect password     assert check_hash(\"wrong_password\", hashed_password) is False</code></p> </li> </ul>"},{"location":"testing/unit/#summary","title":"Summary","text":"<p>The unit tests cover key functionalities such as authentication (hashing and verification), task management (simulating task insertion in the database), and utility functions (ensuring correct hash generation and validation). These tests help ensure the application behaves as expected and that changes to the codebase do not introduce unintended issues.</p>"}]}